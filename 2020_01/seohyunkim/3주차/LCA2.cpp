#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>

#define swap(a,b){int t = a; a = b; b = t;}
#define MAX_NODE 100001

using namespace std;

int depth[MAX_NODE]; //노드의 깊이
int ac[MAX_NODE][20]; //x의 2^y 번째 조상

typedef pair<int, int> pii;
vector<int> graph[MAX_NODE];

int max_level;

//DP(ac) 배열 만드는 과정
void getTree(int here, int parent) {
	//here의 깊이는 부모노드깊이 + 1
	depth[here] = depth[parent] + 1;

	//here의 2^0번째 조상은 부모노드
	ac[here][0] = parent;

	//MAX_NODE에 log2를 씌어 내림을 해준다.
	max_level = (int)floor(log2(MAX_NODE));

	for (int i = 1; i <= max_level; i++)
	{
		//tmp 는 here 의 2^(i-1) 번째 조상일때,
		//here 의 2^i번째 조상은 tmp의 2^(i-1) 번째 조상이다.
		
		int tmp = ac[here][i - 1];
		ac[here][i] = ac[tmp][i - 1];
	}

	// dfs 알고리즘
	int len = graph[here].size();
	for (int i = 0; i < len; i++) {
		int there = graph[here][i];
		if (there != parent)
			getTree(there, here);
	}
}

int main(void) {
	int n, m;

	cin >> n;

	//양방향 그래프
	for (int i = 0; i < n-1; i++) {
		int from, to;
		cin >> from >> to;
		graph[from].push_back(to);
		graph[to].push_back(from);
	}

	depth[0] = -1;

	getTree(1, 0);

	cin >> m;
	vector<int> ans;

	while (m--) {
		int a, b;
		cin >> a >> b;

		if (depth[a] != depth[b]) {

			//depth[b] >= depth[a]가 되도록 swap 
			if (depth[a] > depth[b]) {
				swap(a, b);
			}

			for (int i = max_level; i >= 0; i--)
			{
				// b의 2^i번째 조상이 a의 depth보다 크거나 같으면 계속 조상을 타고간다.
				if (depth[a] <= depth[ac[b][i]])
					b = ac[b][i];
			}
		}

		int lca = a;

		//a 와 b 가 depth 가 같아짐. 
		//a 와 b 가 다르다면 깊이를 계속 올려 서로다른 노드의 조상이 같아질 때까지 반복한다.
		if (a != b)
		{
			for (int i = max_level; i >= 0; i--)
			{
				if (ac[a][i] != ac[b][i])
				{
					a = ac[a][i];
					b = ac[b][i];
				}
				lca = ac[a][i];
			}
		}

		ans.push_back(lca);

	}

	for (int i = 0; i < ans.size(); i++) {
		cout << ans[i] << "\n";
	}
	return 0;
}